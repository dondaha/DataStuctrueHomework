# 第1关：二叉查找树

## 任务描述
二叉排序树，也称为二叉查找树。可以是一棵空树，也可以是一棵具有如下特性的非空二叉树：

若左子树非空，则左子树上所有节点关键字值均小于根节点的关键字值；
若右子树非空，则右子树上所有节点关键字值均大于根节点的关键字值；
左、右子树本身也是一棵二叉排序树。
现在给你N个关键字，要求你按顺序插入一个初始为空树的二叉排序树中，每次插入成功后，求相应父亲节点的关键字值，如果没有父亲节点，则输出-1。

## 输入形式
输入一共两行。

第一行，一个数字N(N<=100)，表示待插入的节点数。

第二行，N个正整数，表示要顺序插入节点的关键字值，用空格分隔。

## 输出形式
输出共N行，每次插入节点后，该节点对应的父亲节点的关键字值。

## 样例输入
```
5
2 5 1 3 4
```
## 样例输出
```
-1
2
2
5
3
```

# 第2关：合并果子

## 任务描述
现在有N堆果子，要把他们合并为一堆。每次合并只能合并其中的两堆，假如要合并的两堆果子分别有a颗果子和b颗果子，那么合并这两堆果子需要消耗a+b点体力。问合并完所有果子需要最小的体力数是多少。

## 输入形式
共两行。

第一行为一个正整数N <= 1000。表示果子总共有多少堆。

第二行共N个正整数，表示第i堆果子的数目（1<=i<=1000）。

## 输出形式
一个正整数，表示消耗的最小体力数。

## 样例输入
```
5
1 2 3 4
```
## 样例输出
```
33
```
## 样例说明
合并1，2消耗体力3，产生一个大小为3的果子堆。

合并3，3消耗体力6，产生一个大小为6的果子堆。

合并4，5消耗体力9，产生一个大小为9的果子堆。

合并6，9消耗体力15，产生一个大小为15的果子堆。

共消耗体力33.

## 注意
严格按照右侧编辑器给出的模板完成任务，不允许以其他方式实现（例如使用C++STL模板priority_queue）
提示：优先队列，贪心算法

# 第3关：散列表的建立
## 任务描述
采用除留余数法构造散列函数H(key) = key mod p，散列表的表长为m，其中p≤m，采用线性探测法处理冲突（当探测到表的最后一个位置仍无空位时，从表的开始位置重新探测）。现将n（n≤m）个互不相同的正整数a1，...，an依次插入到散列表中，要求输出构成的散列表以及在插入每个数时需要探查的次数。

## 输入形式
第一行：参数p，散列表长m，正整数的数目n，每个数用空格隔开；

第二行：n个正整数a1，...，an，每个数用空格隔开。

## 输出形式
第一行：散列表的地址序列（0 1 … m-1），每个数用空格隔开；

第二行：将n个正整数插入到散列表中的结果，每个数用空格隔开；若某个地址中没有数则填为-1；

第三行：每个数在插入时的探查次数；若某个地址中没有数则探查次数为0。

## 样例输入
```
13 15 11
26 36 41 38 44 15 68 12 6 51 25
```
## 样例输出
```
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
26 25 41 15 68 44 6 -1 -1 -1 36 -1 38 12 51
1 5 1 2 2 1 1 0 0 0 1 0 1 2 3
```
## 样例说明
先将11个正整数（26，36，41，38，44，15，68，12，6，51，25）依次插入到表长为15的散列表中，插入过程中采用H(key) = key mod 13来计算插入到表中的位置，若插入位置已有其他数，则采用线性探测法解决冲突。

例：在计算最后一个数25应该插入的位置时，25 mod 13 = 12，但地址12/13/14均无空位，则从地址0开始重新探测，直到地址1有空位，则在地址1中插入25。此时由于依次探查过地址12/13/14/0/1，所以探查次数为5。

